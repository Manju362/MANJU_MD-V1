const { cmd } = require("../command");
const axios = require('axios');
const NodeCache = require('node-cache');

// Cache ‡∂ë‡∂ö initialize ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏ (30 ‡∂≠‡∂≠‡∑ä‡∂¥‡∂ª TTL, max 100 keys)
const searchCache = new NodeCache({ stdTTL: 30, checkperiod: 60, maxKeys: 100 });
const downloadCache = new NodeCache({ stdTTL: 30, checkperiod: 60, maxKeys: 50 });

// Constants
const TIMEOUT_DURATION = 60000; // 60 seconds timeout for listeners
const API_TIMEOUT = 3000; // 3 seconds timeout for API calls
const MAX_RETRIES = 2; // Reduced retries to minimize delay
const RETRY_DELAY = 500; // Reduced retry delay to 500ms
const MAX_FILE_SIZE_GB = 2; // Maximum file size in GB

// ======================
// FROZEN QUEEN ‡∂≠‡∑ö‡∂∏‡∑è‡∑Ä
// ======================
const frozenTheme = {
  header: `‚ï≠‚ïê‚ïê‚ïê‚ùñ‚Ä¢¬∞‚ú¥Ô∏è¬∞‚Ä¢‚ùñ‚ïê‚ïê‚ïê‚ïÆ\n   ùó†ùóîùó°ùóùùó®_ùó†ùóó ùó†ùó¢ùó©ùóúùóò ùó¶ùóúùóßùóòüé•\n   ‚ùÖ ùóßùóõùóò ùó•ùó¢ùóüùóîùó¨ ùóóùóîùó•ùóû ùóûùóúùó°ùóóùó¢ùó† ‚ùÖ\n‚ï∞‚ïê‚ïê‚ïê‚ùñ‚Ä¢¬∞„ÄΩ‚ú¥Ô∏è¬∞‚Ä¢‚ùñ‚ïê‚ïê‚ïê‚ïØ\n`,
  box: function(title, content) {
    return `${this.header}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ ‚ú¥Ô∏è ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n   ‚úß ${title} ‚úß\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ ‚ú¥Ô∏è ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n${content}\n\n‚ú¥Ô∏è‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ ‚ú¥Ô∏è ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ú¥Ô∏è\n‚úß ùóú,ùóîùó†  ùóóùóòùó†ùó¢ùó° ùóßùó¢ ùóßùóõùóúùó¶ ùó™ùóõùó¢ùóüùóò ùó™ùó¢ùó•ùóüùóó. ‚úß`;
  },
  getForwardProps: function() {
    return {
      contextInfo: {
        forwardingScore: 999,
        isForwarded: true,
        stanzaId: "BAE5" + Math.random().toString(16).substr(2, 12).toUpperCase(),
        mentionedJid: [],
        conversionData: {
          conversionDelaySeconds: 0,
          conversionSource: "frozen_queen",
          conversionType: "message"
        }
      }
    };
  },
  resultEmojis: ["üìΩÔ∏è", "üßä", "üëë", "üé•", "üé¨", "üìΩÔ∏è", "üéûÔ∏è", "‚ùÖ", "‚úß", "‚ú≥Ô∏è"]
};

// Utility function to make API calls with retries
const makeApiCall = async (url, retries = MAX_RETRIES) => {
  while (retries > 0) {
    try {
      const response = await axios.get(url, { timeout: API_TIMEOUT });
      console.log(`API Response for ${url}:`, JSON.stringify(response.data, null, 2));
      return response.data;
    } catch (error) {
      console.error(`API Error for ${url}:`, error.message);
      retries--;
      if (retries === 0) throw new Error(`Failed to fetch data: ${error.message}`);
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
    }
  }
};

// Utility function to stream file to WhatsApp with progress updates
const streamFileToWhatsApp = async (conn, from, stream, fileName, caption, quoted) => {
  try {
    // Progress message: Movie uploading
    await conn.sendMessage(from, {
      text: frozenTheme.box("S…™…¥ ú·¥Ä ü·¥Ä S·¥ú ô M·¥è·¥†…™·¥á",
        `Movie uploading... Please wait.`),
      ...frozenTheme.getForwardProps()
    }, { quoted });

    await conn.sendMessage(from, {
      document: stream,
      mimetype: "video/mp4",
      fileName: fileName,
      caption: caption,
      ...frozenTheme.getForwardProps()
    }, { quoted });

    return true;
  } catch (error) {
    throw new Error(`Failed to stream file: ${error.message}`);
  }
};

// Film ‡∑É‡∑ô‡∑Ä‡∑î‡∂∏‡∑ä ‡∑É‡∑Ñ ‡∂©‡∑Ä‡∑î‡∂±‡∑ä‡∂Ω‡∑ù‡∂©‡∑ä command ‡∂ë‡∂ö
cmd({
  pattern: "film",
  react: "üé¨",
  desc: "G·¥á·¥õ M·¥è·¥†…™·¥ás “ì Ä·¥è·¥ç M·¥Ä…¥·¥ä·¥ú_M·¥Ö's ·¥õ Ä·¥á·¥Äs·¥ú Ä è ·¥õ·¥è ·¥á…¥·¥ä·¥è è ·¥Ñ…™…¥·¥á·¥ç·¥Ä",
  category: "D·¥Ä Ä·¥ã K…™…¥·¥Ö·¥è·¥ç",
  filename: __filename,
}, async (conn, mek, m, { from, q, pushname, reply }) => {
  if (!q) {
    return reply(frozenTheme.box("S…™…¥ ú·¥Ä ü·¥Ä S·¥ú ô M·¥è·¥†…™·¥á",
      "Us·¥á : .film <“ì…™ ü·¥ç …¥·¥Ä·¥ç·¥á>\n‚ùÖ ·¥áx: .film Deadpool\n ·¥Ö·¥Ä Ä·¥ã: S…™…¥ ú·¥Ä ü·¥Äs·¥ú ô M·¥è·¥†…™·¥á L…™s·¥õ"));
  }

  try {
    // Step 1: Cache ‡∂ë‡∂ö‡∑ö ‡∂†‡∑í‡∂≠‡∑ä‚Äç‡∂ª‡∂¥‡∂ß ‡∂≠‡∑ú‡∂ª‡∂≠‡∑î‡∂ª‡∑î ‡∂≠‡∑í‡∂∂‡∑ö‡∂Ø‡∑ê‡∂∫‡∑í ‡∂¥‡∂ª‡∑ì‡∂ö‡∑ä‡∑Ç‡∑è ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏
    const cacheKey = `film_search_${q.toLowerCase()}`;
    let searchData = searchCache.get(cacheKey);

    if (!searchData) {
      const searchUrl = `https://apis.davidcyriltech.my.id/movies/search?query=${encodeURIComponent(q)}`;
      searchData = await makeApiCall(searchUrl);

      if (!searchData) {
        throw new Error("No response from the API");
      }

      if (!searchData.status || !searchData.results || searchData.results.length === 0) {
        throw new Error("No movies found in sinhalasub site");
      }

      searchCache.set(cacheKey, searchData);
      console.log(`Cache set for key ${cacheKey}:`, searchData);
    } else {
      console.log(`Cache hit for key ${cacheKey}:`, searchData);
    }

    // Step 2: ‡∂†‡∑í‡∂≠‡∑ä‚Äç‡∂ª‡∂¥‡∂ß ‡∂Ω‡∑ê‡∂∫‡∑í‡∑É‡∑ä‡∂≠‡∑î‡∑Ä format ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏
    let filmList = `Sinhalasub Movie Risalts üé¨\n\n`;
    filmList += `Input : ${q}\n\n`;
    filmList += `Reply Below Number üî¢,\nsinhalasub.lk results\n\n`;

    const films = searchData.results.slice(0, 10).map((film, index) => ({
      number: index + 1,
      title: film.title,
      imdb: film.imdb,
      year: film.year,
      link: film.link,
      image: film.image
    }));

    for (let i = 1; i <= 10; i++) {
      const film = films.find(f => f.number === i);
      filmList += `${i} || ${film ? `${film.title} (${film.year}) Sinhala Subtitles | ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∂ã‡∂¥‡∑É‡∑í‡∂ª‡∑ê‡∑É‡∑í ‡∑É‡∂∏‡∂ü` : ''}\n`;
    }

    filmList += `\n*MANJU_MD SINHALASUB SITE*`;

    // Step 3: ‡∂ª‡∑ñ‡∂¥‡∂∫‡∂ö‡∑ä ‡∂±‡∑ú‡∂∏‡∑ê‡∂≠‡∑í‡∑Ä ‡∂Ω‡∑ê‡∂∫‡∑í‡∑É‡∑ä‡∂≠‡∑î‡∑Ä ‡∂∫‡∑ê‡∑Ä‡∑ì‡∂∏
    const sentMessage = await conn.sendMessage(from, {
      text: filmList,
      ...frozenTheme.getForwardProps()
    }, { quoted: mek });

    console.log("Film list sent with message ID:", sentMessage.key.id);

    // Step 4: ‡∂†‡∑í‡∂≠‡∑ä‚Äç‡∂ª‡∂¥‡∂ß ‡∂≠‡∑ö‡∂ª‡∑ì‡∂∏ ‡∂∂‡∂Ω‡∑è ‡∑É‡∑í‡∂ß‡∑ì‡∂∏ (Single Event Listener)
    const filmSelectionHandler = async (update) => {
      const message = update.messages[0];
      if (!message.message || !message.message.extendedTextMessage) return;

      const userReply = message.message.extendedTextMessage.text.trim();
      const stanzaId = message.message.extendedTextMessage.contextInfo.stanzaId;
      console.log(`Received reply: ${userReply}, stanzaId: ${stanzaId}, expected: ${sentMessage.key.id}`);

      if (stanzaId !== sentMessage.key.id) return;

      const selectedNumber = parseInt(userReply);
      const selectedFilm = films.find(film => film.number === selectedNumber);

      if (!selectedFilm) {
        await conn.sendMessage(from, {
          text: frozenTheme.box("M·¥Ä…¥·¥ä·¥ú W·¥Ä Ä…¥…™…¥…¢",
            "‚ùÖ Invalid selection.!\n  Select a movie number\n D·¥Ä Ä·¥ã …¥…™…¢ ú·¥õ are amazed"),
          ...frozenTheme.getForwardProps()
        }, { quoted: message });
        return;
      }

      // Remove film selection listener
      conn.ev.off("messages.upsert", filmSelectionHandler);
      console.log("Film selection listener removed");

      // Step 5: ‡∂©‡∑Ä‡∑î‡∂±‡∑ä‡∂Ω‡∑ù‡∂©‡∑ä ‡∂Ω‡∑í‡∂±‡∑ä‡∂ö‡∑ä ‡∂Ω‡∂∂‡∑è ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏
      const downloadCacheKey = `download_${selectedFilm.link}`;
      let downloadData = downloadCache.get(downloadCacheKey);

      if (!downloadData) {
        const downloadUrl = `https://apis.davidcyriltech.my.id/movies/download?url=${encodeURIComponent(selectedFilm.link)}`;
        downloadData = await makeApiCall(downloadUrl);

        if (!downloadData) {
          throw new Error("No response from the download API");
        }

        if (!downloadData.status || !downloadData.movie || !downloadData.movie.download_links) {
          throw new Error("There is no download link for sinhalasub site.");
        }

        downloadCache.set(downloadCacheKey, downloadData);
        console.log(`Download cache set for key ${downloadCacheKey}`);
      } else {
        console.log(`Download cache hit for key ${downloadCacheKey}`);
      }

      const downloadLinks = [];
      const allLinks = downloadData.movie.download_links;

      const sdLink = allLinks.find(link => link.quality === "SD 480p" && link.direct_download);
      if (sdLink) {
        downloadLinks.push({
          number: 1,
          quality: "SD QUALITY",
          size: sdLink.size,
          url: sdLink.direct_download
        });
      }

      let hdLink = allLinks.find(link => link.quality === "HD 720p" && link.direct_download);
      if (!hdLink) {
        hdLink = allLinks.find(link => link.quality === "FHD 1080p" && link.direct_download);
      }

      if (hdLink) {
        downloadLinks.push({
          number: 2,
          quality: "HD QUALITY",
          size: hdLink.size,
          url: hdLink.direct_download
        });
      }

      if (downloadLinks.length === 0) {
        throw new Error("SD ‡∑Ñ‡∑ù HD ‡∂ú‡∑î‡∂´‡∑è‡∂≠‡∑ä‡∂∏‡∂ö ‡∂Ω‡∑í‡∂±‡∑ä‡∂ö‡∑ä ‡∂±‡∑ú‡∂∏‡∑ê‡∂≠");
      }

      // Step 6: ‡∂©‡∑Ä‡∑î‡∂±‡∑ä‡∂Ω‡∑ù‡∂©‡∑ä ‡∂∂‡∂ß‡∂±‡∑ä format ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏
      let downloadOptions = `S…™…¥ ú·¥Ä ü·¥ÄS·¥ú ô M·¥è·¥†…™·¥á D·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö S…™·¥õ·¥á üé•\n\n`;
      downloadOptions += `*${selectedFilm.title} (${selectedFilm.year}) Sinhala Subtitles | ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∂ã‡∂¥‡∑É‡∑í‡∂ª‡∑ê‡∑É‡∑í ‡∑É‡∂∏‡∂ü*\n\n`;
      downloadOptions += `M·¥è·¥†…™·¥á Q·¥ú·¥Ä ü…™·¥õ è ‚òïÔ∏é>\n\n`;

      downloadLinks.forEach(link => {
        downloadOptions += `${link.number}.${link.quality} (${link.size})\n`;
      });

      downloadOptions += `\nP·¥è·¥°·¥á Ä·¥Ö B è M·¥Ä…¥·¥ä·¥ú_MD ‚úîÔ∏é`;

      const downloadMessage = await conn.sendMessage(from, {
        image: { url: downloadData.movie.thumbnail || selectedFilm.image || "https://i.ibb.co/5Yb4VZy/snowflake.jpg" },
        caption: downloadOptions,
        ...frozenTheme.getForwardProps()
      }, { quoted: message });

      console.log("Download options sent with message ID:", downloadMessage.key.id);

      // Step 7: Quality selection awaits (Single Event Listener)
      const qualitySelectionHandler = async (updateQuality) => {
        const qualityMessage = updateQuality.messages[0];
        if (!qualityMessage.message || !qualityMessage.message.extendedTextMessage) return;

        const qualityReply = qualityMessage.message.extendedTextMessage.text.trim();
        const qualityStanzaId = qualityMessage.message.extendedTextMessage.contextInfo.stanzaId;
        console.log(`Received quality reply: ${qualityReply}, stanzaId: ${qualityStanzaId}, expected: ${downloadMessage.key.id}`);

        if (qualityStanzaId !== downloadMessage.key.id) return;

        const selectedQualityNumber = parseInt(qualityReply);
        const selectedLink = downloadLinks.find(link => link.number === selectedQualityNumber);

        if (!selectedLink) {
          await conn.sendMessage(from, {
            text: frozenTheme.box("M·¥Ä…¥·¥ä·¥ú W·¥Ä Ä…¥…™…¥…¢",
              " Invalid quality!\n Choose a quality number\n D·¥Ä Ä·¥ã Ä·¥Ä è are amazed"),
            ...frozenTheme.getForwardProps()
          }, { quoted: qualityMessage });
          return;
        }

        // Remove quality selection listener
        conn.ev.off("messages.upsert", qualitySelectionHandler);
        console.log("Quality selection listener removed");

        // Step 8: ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä‡∑ö ‡∂¥‡∑ä‚Äç‡∂ª‡∂∏‡∑è‡∂´‡∂∫ ‡∂¥‡∂ª‡∑ì‡∂ö‡∑ä‡∑Ç‡∑è ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏
        try {
          const sizeStr = selectedLink.size.toLowerCase();
          let sizeInGB = 0;

          if (sizeStr.includes("gb")) {
            sizeInGB = parseFloat(sizeStr.replace("gb", "").trim());
          } else if (sizeStr.includes("mb")) {
            sizeInGB = parseFloat(sizeStr.replace("mb", "").trim()) / 1024;
          }

          console.log(`File size: ${sizeInGB} GB`);

          if (sizeInGB > MAX_FILE_SIZE_GB) {
            await conn.sendMessage(from, {
              text: frozenTheme.box("D·¥Ä Ä·¥ã W·¥Ä Ä…¥…™…¥…¢",
                ` The product is too big. (${selectedLink.size})!\n  Download directly: ${selectedLink.url}\n Choose a small quality`),
              ...frozenTheme.getForwardProps()
            }, { quoted: qualityMessage });
            return;
          }
        } catch (error) {
          console.error("Error during file size check:", error);
          await conn.sendMessage(from, {
            text: frozenTheme.box("S…™…¥ ú·¥Ä ü·¥ÄS·¥ú ô A·¥õ·¥õ·¥á…¥·¥õ…™·¥è…¥",
              `‚ùÖ Error during file size check: ${error.message}\n‚ùÖ Please try again.`),
            ...frozenTheme.getForwardProps()
          }, { quoted: qualityMessage });
          return;
        }

        // Step 9: Download ‡∂ë‡∂ö ‡∂Ü‡∂ª‡∂∏‡∑ä‡∂∑ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏
        let downloadStream;
        try {
          const response = await axios({
            url: selectedLink.url,
            method: 'GET',
            responseType: 'stream',
            timeout: 30000 // 30 seconds timeout for download
          });
          downloadStream = response.data;

          console.log("Download stream created successfully");

          // Progress message: Download successfully
          await conn.sendMessage(from, {
            text: frozenTheme.box("S…™…¥ ú·¥Ä ü·¥Ä S·¥ú ô M·¥è·¥†…™·¥á",
              `Download successfully`),
            ...frozenTheme.getForwardProps()
          }, { quoted: qualityMessage });

        } catch (error) {
          console.error("Error during download:", error);
          await conn.sendMessage(from, {
            text: frozenTheme.box("s…™…¥ ú·¥Ä ü·¥Äs·¥ú ô ·¥°·¥Ä Ä…¥…™…¥…¢",
              ` ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ “ì·¥Ä…™ ü·¥Ö: ${error.message}\n‚ùÖ ·¥Ö…™ Ä·¥á·¥Ñ·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö: ${selectedLink.url}\n ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥`),
            ...frozenTheme.getForwardProps()
          }, { quoted: qualityMessage });
          return;
        }

        // Step 10: ‡∂†‡∑í‡∂≠‡∑ä‚Äç‡∂ª‡∂¥‡∂ß‡∂∫ stream ‡∂ö‡∂ª‡∂Ω‡∑è ‡∂ë‡∑Ä‡∂±‡∑ä‡∂± with "Movie uploading" message
        try {
          const startTime = Date.now();
          await streamFileToWhatsApp(
            conn,
            from,
            downloadStream,
            `${selectedFilm.title} - ${selectedLink.quality}.mp4`,
            frozenTheme.box("S…™…¥ ú·¥Ä ü·¥Ä s·¥ú ô M·¥è·¥†…™·¥ás",
              `${frozenTheme.resultEmojis[3]} *${selectedFilm.title}*\n${frozenTheme.resultEmojis[4]} «´·¥ú·¥Ä ü ü…™·¥õ è: ${selectedLink.quality}\n${frozenTheme.resultEmojis[2]} B…™…¢ “ì…™ ü·¥á: ${selectedLink.size}\n\n${frozenTheme.resultEmojis[8]} Your item shines in the M·¥Ä…¥·¥ä·¥ú_M·¥Ö.!\n${frozenTheme.resultEmojis[9]} M·¥Ä…¥·¥ä·¥ú_·¥ç·¥Ö ·¥ò·¥è·¥°·¥á Ä·¥Ö  ô è ·¥ò·¥Ä·¥õ ú·¥ú·¥ç  Ä·¥Ä·¥¢·¥Ä·¥ò·¥Ä·¥ãs ú·¥á`),
            qualityMessage
          );

          const endTime = Date.now();
          const uploadTime = (endTime - startTime) / 1000; // seconds
          console.log(`Upload completed in ${uploadTime} seconds`);

          await conn.sendMessage(from, { react: { text: frozenTheme.resultEmojis[0], key: qualityMessage.key } });
        } catch (uploadError) {
          console.error("Error during upload:", uploadError);
          await conn.sendMessage(from, {
            text: frozenTheme.box("s…™…¥ ú·¥Ä ü·¥Äs·¥ú ô ·¥°·¥Ä Ä…¥…™…¥…¢",
              ` ·¥ú·¥ò ü·¥è·¥Ä·¥Ö…™…¥…¢ “ì·¥Ä…™ ü·¥Ö: ${uploadError.message}\n‚ùÖ ·¥Ö…™ Ä·¥á·¥Ñ·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö: ${selectedLink.url}\n ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥`),
            ...frozenTheme.getForwardProps()
          }, { quoted: qualityMessage });
        }
      };

      // Register quality selection listener with timeout
      conn.ev.on("messages.upsert", qualitySelectionHandler);
      setTimeout(() => {
        conn.ev.off("messages.upsert", qualitySelectionHandler);
        console.log("Quality selection listener timed out and removed");
      }, TIMEOUT_DURATION);
    };

    // Register film selection listener with timeout
    conn.ev.on("messages.upsert", filmSelectionHandler);
    setTimeout(() => {
      conn.ev.off("messages.upsert", filmSelectionHandler);
      console.log("Film selection listener timed out and removed");
    }, TIMEOUT_DURATION);

  } catch (e) {
    console.error("‡∂Ø‡∑ù‡∑Ç‡∂∫:", e);
    const errorMsg = frozenTheme.box("S…™…¥ ú·¥Ä ü·¥ÄS·¥ú ô A·¥õ·¥õ·¥á…¥·¥õ…™·¥è…¥",
      `‚ùÖ ‡∂Ø‡∑ù‡∑Ç‡∂∫: ${e.message || "s…™…¥ ú·¥Ä ü·¥ÄS·¥ú ô destroyed the treasury"}\n‚ùÖ The s…™…¥ ú·¥Ä ü·¥ÄS·¥ú ô s…™·¥õ·¥á is closed.\n‚ùÖ F…™x·¥á·¥Ö ·¥¢·¥è·¥è…¥ T Ä è  ü·¥Ä…™·¥õ·¥á Ä`);

    await reply(errorMsg);
    await conn.sendMessage(from, { react: { text: "‚ùå", key: mek.key } });
  }
});
